<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Brutalist Text Processor</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Fira Mono', monospace;
    }
    /* Subtle animation for buttons */
    .btn {
      transition: background-color 0.2s ease-in-out;
    }
    .btn:hover {
      background-color: #e5e7eb;
    }
    /* Mobile pop-up menu */
    #mobileMenu.hidden {
      display: none;
    }
  </style>
</head>
<body class="bg-white text-black">
  <div class="container mx-auto p-4">
    <!-- Desktop Layout -->
    <div class="hidden md:flex">
      <!-- Input Textarea -->
      <textarea id="inputText" class="w-1/3 h-screen p-4 border-2 border-black" placeholder="Enter text here..."></textarea>
      <!-- Buttons -->
      <div id="buttonMenu" class="w-1/3 flex flex-col items-center justify-center space-y-4 p-4">
        <!-- Buttons will be rendered here -->
      </div>
      <!-- Output Textarea -->
      <textarea id="outputText" class="w-1/3 h-screen p-4 border-2 border-black" placeholder="Processed text will appear here..." readonly></textarea>
    </div>
    <!-- Mobile Layout -->
    <div class="md:hidden flex flex-col">
      <!-- Input Textarea -->
      <textarea id="inputTextMobile" class="w-full h-48 p-4 border-2 border-black" placeholder="Enter text here..."></textarea>
      <!-- Output Textarea -->
      <textarea id="outputTextMobile" class="w-full h-48 p-4 border-2 border-black mt-4" placeholder="Processed text will appear here..." readonly></textarea>
    </div>
    <!-- Character Count -->
    <div id="charCount" class="mt-2 text-center"></div>
  </div>
  <!-- Mobile Menu Button -->
  <button id="mobileMenuButton" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-black text-white p-4 rounded-full md:hidden">
    Menu
  </button>
  <!-- Mobile Pop-up Menu -->
  <div id="mobileMenu" class="fixed bottom-0 inset-x-0 bg-white border-t-2 border-black p-4 hidden md:hidden">
    <!-- Buttons will be rendered here -->
  </div>

  <!-- JavaScript Code -->
  <script>
    // Debounce utility to limit the rate at which a function can fire.
    function debounce(func, delay) {
      let debounceTimeout;
      return function() {
        const context = this;
        const args = arguments;
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => func.apply(context, args), delay);
      };
    }

    // Transformation functions
    function handleSpecialCharacters(text) {
      const specialCharacters = ["-", "â€”", "&", "_", ",", ".", "!", "?", ":", ";", "(", ")", "[", "]", "{", "}", '"', "'"];
      specialCharacters.forEach((char) => {
        const regex = new RegExp(`[${escapeRegExp(char)}]+`, "g");
        text = text.replace(regex, char);
      });
      return text;
    }

    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function applyWordMap(text) {
      const wordMap = {
        about: "abt", after: "aftr", algorithm: "algo", all: "al", before: "b4",
        development: "dev", example: "ex", information: "info", organization: "org",
        system: "sys", technology: "tech", without: "w/o"
      };
      const regex = new RegExp(`\\b(${Object.keys(wordMap).join("|")})\\b`, "gi");
      return text.replace(regex, (matched) => wordMap[matched.toLowerCase()] || matched);
    }

    function removeVowels(text, removeCapitals) {
      if (removeCapitals) {
        return text.replace(/[aeiou]/gi, "");
      } else {
        return text.replace(/[aeiou]/g, "");
      }
    }

    function removeSpaces(text) {
      return text.replace(/\u0020/g, "");
    }

    function removeLineBreaks(text) {
      return text.replace(/\r?\n|\r/g, "");
    }

    function removeFillerWords(text) {
      const fillerWords = ["basically", "actually", "honestly", "literally", "just", "really", "very", "so"];
      const regex = new RegExp(`\\b(${fillerWords.join("|")})\\b`, "gi");
      return text.replace(regex, "").replace(/\s{2,}/g, " ").trim();
    }

    function removeComments(text, type) {
      if (type === "//") {
        return text.replace(/\/\/.*$/gm, "");
      } else if (type === "#") {
        return text.replace(/#.*$/gm, "");
      }
      return text;
    }

    function removeBlockComments(text) {
      return text.replace(/\/\*[\s\S]*?\*\//g, "");
    }

    function removeHTMLComments(text) {
      return text.replace(/<!--[\s\S]*?-->/g, "");
    }

    // Main text processing function
    function processText() {
      try {
        const inputElement = document.getElementById('inputText') || document.getElementById('inputTextMobile');
        const outputElement = document.getElementById('outputText') || document.getElementById('outputTextMobile');
        const charCountElement = document.getElementById("charCount");
        if (!inputElement || !outputElement || !charCountElement) {
          throw new Error("Required DOM elements are missing.");
        }
        const inputText = inputElement.value;
        let outputText = inputText;

        // Apply transformations based on selected options
        transformations.forEach(transform => {
          outputText = transform.action(outputText);
        });

        // Update the output textarea and character count
        outputElement.value = outputText;
        charCountElement.textContent = `Original: ${inputText.length} characters, Cleaned: ${inputText.length - outputText.length} characters, Output: ${outputText.length} characters`;
      } catch (error) {
        console.error("Error processing text:", error);
      }
    }

    // Transformation functions array
    let transformations = [];

    // Event listeners for buttons
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize buttons
      const buttonsData = [
        { id: 'specialCharacters', label: 'Handle Special Characters', action: handleSpecialCharacters },
        { id: 'wordmap', label: 'Apply Word Map', action: applyWordMap },
        { id: 'removeVowels', label: 'Remove Vowels', action: removeVowelsWrapper },
        { id: 'removeSpaces', label: 'Remove Spaces', action: removeSpaces },
        { id: 'removeLineBreaks', label: 'Remove Line Breaks', action: removeLineBreaks },
        { id: 'fillerWords', label: 'Remove Filler Words', action: removeFillerWords },
        { id: 'removeDoubleSlashComments', label: 'Remove // Comments', action: (text) => removeComments(text, "//") },
        { id: 'removeHashComments', label: 'Remove # Comments', action: (text) => removeComments(text, "#") },
        { id: 'removeBlockComments', label: 'Remove Block Comments', action: removeBlockComments },
        { id: 'removeHTMLComments', label: 'Remove HTML Comments', action: removeHTMLComments },
      ];

      // Function to wrap removeVowels with option to remove capitals
      function removeVowelsWrapper(text) {
        const removeVowelsCapitals = document.getElementById('removeVowelsCapitals').checked;
        return removeVowels(text, removeVowelsCapitals);
      }

      // Function to create buttons
      function createButtons(container) {
        buttonsData.forEach(buttonData => {
          const btn = document.createElement('button');
          btn.id = buttonData.id;
          btn.textContent = buttonData.label;
          btn.className = 'btn bg-white border-2 border-black p-2 w-full';
          btn.addEventListener('click', () => {
            const index = transformations.findIndex(t => t.id === buttonData.id);
            if (index >= 0) {
              transformations.splice(index, 1);
              btn.classList.remove('bg-black', 'text-white');
              btn.classList.add('bg-white', 'text-black');
            } else {
              transformations.push(buttonData);
              btn.classList.remove('bg-white', 'text-black');
              btn.classList.add('bg-black', 'text-white');
            }
            processText();
          });
          container.appendChild(btn);

          // For 'Remove Vowels', add checkbox
          if (buttonData.id === 'removeVowels') {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = 'removeVowelsCapitals';
            checkbox.className = 'ml-2';
            const label = document.createElement('label');
            label.textContent = 'Remove Capitals';
            label.htmlFor = 'removeVowelsCapitals';
            label.className = 'ml-1 text-sm';
            const wrapper = document.createElement('div');
            wrapper.className = 'flex items-center mb-2';
            wrapper.appendChild(checkbox);
            wrapper.appendChild(label);
            container.appendChild(wrapper);

            // Add event listener to checkbox to re-process text when changed
            checkbox.addEventListener('change', processText);
          }
        });
      }

      // Render buttons in both desktop and mobile containers
      const desktopButtonContainer = document.getElementById('buttonMenu');
      const mobileButtonContainer = document.getElementById('mobileMenu');

      if (desktopButtonContainer) {
        createButtons(desktopButtonContainer);
      }
      if (mobileButtonContainer) {
        createButtons(mobileButtonContainer);
      }

      // Event listener for input changes
      const inputElements = document.querySelectorAll('#inputText, #inputTextMobile');
      inputElements.forEach(inputElement => {
        inputElement.addEventListener('input', debounce(processText, 300));
      });

      // Mobile menu toggle
      const mobileMenuButton = document.getElementById('mobileMenuButton');
      const mobileMenu = document.getElementById('mobileMenu');
      if (mobileMenuButton) {
        mobileMenuButton.addEventListener('click', () => {
          mobileMenu.classList.toggle('hidden');
        });
      }
    });
  </script>
</body>
</html>
