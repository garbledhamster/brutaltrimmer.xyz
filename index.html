<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Brutal Trimmer - Text Processor</title>

  <!-- Meta Tags for SEO -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Brutal Trimmer is a powerful online text processing tool for developers, writers, and editors to clean and transform text efficiently.">
  <meta name="keywords" content="text processor, text trimmer, online tool, remove comments, text cleaner, code formatter, text transformation, brutal trimmer">
  <meta name="author" content="Brutal Trimmer">

  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="Brutal Trimmer - Online Text Processor">
  <meta property="og:description" content="Clean and transform your text with Brutal Trimmer's powerful online tools.">
  <meta property="og:image" content="assets/favicon/favicon-32x32.png">
  <meta property="og:url" content="https://garbledhamster.github.io/brutaltrimmer.xyz">
  <meta property="og:type" content="website">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Brutal Trimmer - Online Text Processor">
  <meta name="twitter:description" content="Clean and transform your text with Brutal Trimmer's powerful online tools.">
  <meta name="twitter:image" content="assets/favicon/favicon-512x512.png">

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="assets/favicon/site.webmanifest">
  <link rel="shortcut icon" href="assets/favicon/favicon.ico">

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">

  <!-- Custom Styles -->
  <style>
    body {
      font-family: 'Fira Mono', monospace;
      background-image: url('assets/backgrounds/current.jpeg');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
      color: black;
    }

    /* Subtle animation for buttons */
    .btn {
      color: #f8f8f2; /* Monokai foreground color */
      border: 2px solid #f8f8f2; /* Light border for contrast */
      transition: background-color 0.2s ease-in-out;
    }

    .btn:hover {
      filter: brightness(110%);
    }

    /* Monokai color scheme */
    .btn-color-1 { background-color: #F6F5EC; } /* Lightest color */
    .btn-color-2 { background-color: #DFDED5; }
    .btn-color-3 { background-color: #C8C7BE; }
    .btn-color-4 { background-color: #B1B0A7; }
    .btn-color-5 { background-color: #9A9990; }
    .btn-color-6 { background-color: #838279; }
    .btn-color-7 { background-color: #6C6B62; }
    .btn-color-8 { background-color: #55544A; }
    .btn-color-9 { background-color: #3E3D32; }
    .btn-color-10 { background-color: #272822; } /* Darkest color */

    /* Textarea styling */
    textarea {
      background-color: rgba(0, 0, 0, 0.8);
      color: #f8f8f2; /* Monokai foreground color */
    }

    /* For readability */
    ::placeholder {
      color: #75715e;
    }

    /* Header text styling */
    header {
      color: white;
      text-shadow: 1px 1px 2px black;
    }

    /* Mobile pop-up menu */
    #mobileMenu.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container mx-auto p-4">
    <!-- Header -->
    <header class="text-center mb-8">
      <h1 class="text-4xl font-bold">Brutal Trimmer</h1>
      <p class="text-xl">Efficient Text Processing Tool</p>
    </header>
    <!-- Desktop Layout -->
    <div class="hidden md:flex">
      <!-- Input Textarea -->
      <textarea id="inputText" class="w-1/3 h-screen p-4 border-2 border-black" placeholder="Enter text here..."></textarea>
      <!-- Buttons -->
      <div id="buttonMenu" class="w-1/3 h-screen flex flex-col items-center justify-start space-y-4 p-4 overflow-y-auto">
        <!-- Buttons will be rendered here -->
      </div>
      <!-- Output Textarea -->
      <textarea id="outputText" class="w-1/3 h-screen p-4 border-2 border-black" placeholder="Processed text will appear here..." readonly></textarea>
    </div>
    <!-- Mobile Layout -->
    <div class="md:hidden flex flex-col">
      <!-- Input Textarea -->
      <textarea id="inputTextMobile" class="w-full h-48 p-4 border-2 border-black" placeholder="Enter text here..."></textarea>
      <!-- Output Textarea -->
      <textarea id="outputTextMobile" class="w-full h-48 p-4 border-2 border-black mt-4" placeholder="Processed text will appear here..." readonly></textarea>
    </div>
    <!-- Character Count -->
    <div id="charCount" class="mt-2 text-center"></div>
  </div>
  <!-- Mobile Menu Button -->
  <button id="mobileMenuButton" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-black text-white p-4 rounded-full md:hidden z-50">
    Menu
  </button>
  <!-- Mobile Pop-up Menu -->
  <div id="mobileMenu" class="fixed bottom-16 inset-x-0 bg-black bg-opacity-90 p-4 hidden md:hidden flex flex-wrap overflow-y-auto" style="max-height: 50vh;">
    <!-- Buttons will be rendered here -->
  </div>

  <!-- JavaScript Code -->
  <script>
    // Debounce utility to limit the rate at which a function can fire.
    function debounce(func, delay) {
      let debounceTimeout;
      return function() {
        const context = this;
        const args = arguments;
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => func.apply(context, args), delay);
      };
    }

    // Transformation functions
    function handleSpecialCharacters(text) {
      const specialCharacters = ["-", "â€”", "&", "_", ",", ".", "!", "?", ":", ";", "(", ")", "[", "]", "{", "}", '"', "'"];
      specialCharacters.forEach((char) => {
        const regex = new RegExp(`[${escapeRegExp(char)}]+`, "g");
        text = text.replace(regex, char);
      });
      return text;
    }

    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function applyWordMap(text) {
      const wordMap = {
        about: "abt", after: "aftr", algorithm: "algo", all: "al", before: "b4",
        development: "dev", example: "ex", information: "info", organization: "org",
        system: "sys", technology: "tech", without: "w/o"
      };
      const regex = new RegExp(`\\b(${Object.keys(wordMap).join("|")})\\b`, "gi");
      return text.replace(regex, (matched) => wordMap[matched.toLowerCase()] || matched);
    }

    function removeVowels(text) {
      return text.replace(/[aeiouAEIOU]/g, "");
    }

    function removeCapitals(text) {
      return text.replace(/[A-Z]/g, "");
    }

    function removeSpaces(text) {
      return text.replace(/\u0020/g, "");
    }

    function removeLineBreaks(text) {
      return text.replace(/\r?\n|\r/g, "");
    }

    function removeFillerWords(text) {
      const fillerWords = ["basically", "actually", "honestly", "literally", "just", "really", "very", "so"];
      const regex = new RegExp(`\\b(${fillerWords.join("|")})\\b`, "gi");
      return text.replace(regex, "").replace(/\s{2,}/g, " ").trim();
    }

    function removeComments(text, type) {
      if (type === "//") {
        return text.replace(/\/\/.*$/gm, "");
      } else if (type === "#") {
        return text.replace(/#.*$/gm, "");
      }
      return text;
    }

    function removeBlockComments(text) {
      return text.replace(/\/\*[\s\S]*?\*\//g, "");
    }

    function removeHTMLComments(text) {
      return text.replace(/<!--[\s\S]*?-->/g, "");
    }

    // Main text processing function
    function processText() {
      try {
        const inputElement = document.getElementById('inputText') || document.getElementById('inputTextMobile');
        const outputElement = document.getElementById('outputText') || document.getElementById('outputTextMobile');
        const charCountElement = document.getElementById("charCount");
        if (!inputElement || !outputElement || !charCountElement) {
          throw new Error("Required DOM elements are missing.");
        }
        const inputText = inputElement.value;
        let outputText = inputText;

        // Apply transformations based on selected options
        transformations.forEach(transform => {
          outputText = transform.action(outputText);
        });

        // Update the output textarea and character count
        outputElement.value = outputText;
        charCountElement.textContent = `Original: ${inputText.length} characters, Cleaned: ${inputText.length - outputText.length} characters, Output: ${outputText.length} characters`;
      } catch (error) {
        console.error("Error processing text:", error);
      }
    }

    // Transformation functions array
    let transformations = [];

    // Event listeners for buttons
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize buttons
      const buttonsData = [
        { id: 'specialCharacters', label: 'Handle Special Characters', action: handleSpecialCharacters },
        { id: 'wordmap', label: 'Apply Word Map', action: applyWordMap },
        { id: 'removeVowels', label: 'Remove Vowels', action: removeVowels },
        { id: 'removeCapitals', label: 'Remove Capitals', action: removeCapitals },
        { id: 'removeSpaces', label: 'Remove Spaces', action: removeSpaces },
        { id: 'removeLineBreaks', label: 'Remove Line Breaks', action: removeLineBreaks },
        { id: 'fillerWords', label: 'Remove Filler Words', action: removeFillerWords },
        { id: 'removeDoubleSlashComments', label: 'Remove // Comments', action: (text) => removeComments(text, "//") },
        { id: 'removeHashComments', label: 'Remove # Comments', action: (text) => removeComments(text, "#") },
        { id: 'removeBlockComments', label: 'Remove Block Comments', action: removeBlockComments },
        { id: 'removeHTMLComments', label: 'Remove HTML Comments', action: removeHTMLComments },
      ];

      // Function to create buttons
      function createButtons(container) {
        const isMobile = container.id === 'mobileMenu';
        const totalColors = 10; // Total number of color classes
        buttonsData.forEach((buttonData, index) => {
          const colorIndex = totalColors - (index % totalColors); // Reverses the color index
          const btn = document.createElement('button');
          btn.id = buttonData.id;
          btn.textContent = buttonData.label;
          btn.className = `btn border-2 border-black p-2 ${isMobile ? 'w-1/2' : 'w-full'} btn-color-${colorIndex}`;
          btn.addEventListener('click', () => {
            const existingIndex = transformations.findIndex(t => t.id === buttonData.id);
            if (existingIndex >= 0) {
              transformations.splice(existingIndex, 1);
              btn.classList.remove('border-white');
              btn.classList.add('border-black');
            } else {
              transformations.push(buttonData);
              btn.classList.remove('border-black');
              btn.classList.add('border-white');
            }
            processText();
          });
          container.appendChild(btn);
        });
      }

      // Render buttons in both desktop and mobile containers
      const desktopButtonContainer = document.getElementById('buttonMenu');
      const mobileButtonContainer = document.getElementById('mobileMenu');

      if (desktopButtonContainer) {
        createButtons(desktopButtonContainer);
      }
      if (mobileButtonContainer) {
        createButtons(mobileButtonContainer);
      }

      // Event listener for input changes
      const inputElements = document.querySelectorAll('#inputText, #inputTextMobile');
      inputElements.forEach(inputElement => {
        inputElement.addEventListener('input', debounce(processText, 300));
      });

      // Mobile menu toggle
      const mobileMenuButton = document.getElementById('mobileMenuButton');
      const mobileMenu = document.getElementById('mobileMenu');
      if (mobileMenuButton) {
        mobileMenuButton.addEventListener('click', () => {
          mobileMenu.classList.toggle('hidden');
        });
      }
    });
  </script>
</body>
</html>
